## 链表

链表是空节点或者是一个值和一个指向下一个节点的指针，因此很多链表操作都可以用递归来完成（并且递归时间复杂度一般为 O(n) );

通用操作是在链表中查找一个节点，删除一个节点，更改某个节点的值，头插法和尾插法创建链表。也就是增删改查。

实现很简单，此处不赘述

下面是链表相关的经典算法问题

## 1 找出两个链表的交点

[力扣](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/)

输入两个链表的头指针，输出交点指针，要求常数空间复杂度（不能使用递归操作），O(n) 时间复杂度

思路：

设相交链表长度为c，链表A长度为a+c，链表B长度为b+c。

能不能通过算占用空间来求？？？？

第一步：求得AB长度和差值 d = len(A) - len(B)

第二步：长的先走 d 步，然后逐个节点，第一个相同节点即为交点。

```c++
static int GetListLength(ListNode* head)
{
    if (head == nullptr)
        return 0;
    int length = 0;
    while (head != nullptr)
    {
        head = head->next;
        length++;
    }
    return length;
}

static ListNode* StepForward(ListNode* head, int step)
{
    while (head!= nullptr && step>0)
    {
        head = head->next;
        step--;
    }
    return head;
}

static ListNode* FindIntersection(ListNode *headA, ListNode *headB)
{
    while (headA!= nullptr && headB!= nullptr)
    {
        if (headA == headB)
        {
            break;
        } else
        {
            headA = headA->next;
            headB = headB->next;
        }
    }
    if (headA != nullptr && headB!= nullptr)
        return headA;
    else
        return nullptr;
}

static ListNode *GetIntersectionNode(ListNode *headA, ListNode *headB)
{
    ListNode* intersection_node;
    int len_A;
    int len_B;

    len_A = GetListLength(headA);
    len_B = GetListLength(headB);

    int difference = abs((len_A - len_B));

    if (difference > 0)
    {
        if (len_A > len_B)
        {
            headA = StepForward(headA, difference);
            intersection_node = FindIntersection(headA, headB);
        } else
        {
            headB = StepForward(headB, difference);
            intersection_node = FindIntersection(headA, headB);
        }
    } else
    {
        intersection_node = FindIntersection(headA, headB);
    }

    return intersection_node;

}
```

这是实现代码，但是评论区我看到了一个骚答案，思路如下

链表 A 长为 a+c ，链表 B 长为 b+c ，用两个指针分别指向 A B 的头部，同时遍历链表，当其中一个到达尾部时，指向另一个链表的头部，如果有交点，会在第二趟相遇在交点。原理很简单：a+c+b = b+c+a；实现代码如下：

```c++
static ListNode* GetIntersectionNode2(ListNode *headA, ListNode *headB)
{
    if (headA == nullptr || headB == nullptr)
        return nullptr;

    ListNode *p_A = headA, *p_B = headB;

    while (p_A != p_B)
    {
        p_A = p_A ? p_A->next : headB;
        p_B = p_B ? p_B->next : headA;
    }

    if (p_A!= nullptr && p_B!= nullptr)
        return p_A;
    else
        return nullptr;

}
```

## 2 链表反转

[力扣](https://leetcode-cn.com/problems/reverse-linked-list/description/)

反转链表是一道经典题目，用到了链表指针的处理。

有两种实现方式，分别是迭代式反转和递归式反转，其中递归反转链表值得注意

迭代实现反转链表如下：

```c++
static ListNode* ReverseListIteration(ListNode *head)
{
    if (head == nullptr)
        return nullptr;
    ListNode *current = head, *pre = nullptr;
    while (current!= nullptr)
    {
        ListNode *tmp_node = current->next;
        current->next = pre;
        pre = current;
        current = tmp_node;
    }
    return pre;
}
```

递归实现反转链表如下：

```c++
static ListNode* ReverseListRecursion(ListNode *head)
{
    if (head == nullptr || head->next == nullptr)
        return head;
    ListNode *new_head = ReverseListIteration(head->next);

    head->next->next = head;
    head->next = nullptr;
    return new_head;
}
```

## 3 合并两个有序链表

[力扣](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 实现代码如下

我发现很多时候哑结点是很有用的

```c++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)
{
    ListNode* dummy = new ListNode(0, nullptr), *current = dummy;
    while (l1!= nullptr && l2!= nullptr)
    {
        if (l1->val <= l2->val)
        {
            current->next = l1;
            current = current->next;
            l1 = l1->next;
        } else
        {
            current->next = l2;
            current = current->next;
            l2 = l2->next;
        }
    }

    if (l1 != nullptr)
    {
        current->next = l1;
    }
    if (l2!= nullptr)
    {
        current->next = l2;
    }
    return dummy->next;

}
```

当然还有递归版本的实现：

```c++
ListNode* mergeTwoLists_recursion(ListNode* l1, ListNode* l2)
{
    // 递归处理边界情况
    if (l1 == nullptr)
        return l2;
    if (l2 == nullptr)
        return l1;
    if (l1->val <= l2->val)
    {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    }
    else
    {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
}
```

## 4 删除排序链表中的重复元素：

[力扣](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

存在一个按升序排列的链表，给你这个链表的头节点 `head` ，请你删除所有重复的元素，使每个元素 **只出现一次** 

实现如下：

```
ListNode* deleteDuplicates(ListNode* head)
    {
        //我觉得需要一个字典来存放已经存在的值
//        map<int, int>
        set<int> exist_value;
        ListNode* current = head;
        ListNode* pre = new ListNode(0, nullptr);
        pre->next = current;
        while (current!= nullptr)
        {
            if (exist_value.count(current->val))
            {
                pre->next = current->next;
                current = current->next;
            } else
            {
                exist_value.insert(current->val);
                pre = current;
                current = current->next;
            }
        }
        return head;
    }
```

当然，这道题目也可以用递归的方式解决（因为这道题目是升序的，我上面写的代码可以用于无序的链表，所以时间复杂度为 On)：

递归思路

-   终止条件，判断 head 是否为单节点和空节点，如果是，则返回 head，因为 head 不可能是一个有重复节点的链表。
-   递归主体，对 head->next 部分进行递归，返回的是没有重复节点的链表的头指针。
-   返回递归结果，如果 head 和 head->next 的头节点值一样，那么返回 head->next 的头节点，否则 head 连上 head->next 的头节点一起返回

实现代码如下：

```c++
ListNode* deleteDuplicates_recursion(ListNode* head)
{
    if (head== nullptr || head->next == nullptr) //这个写法很绝妙啊，如果head为空指针的化，就不用判断对后面进行判断了，判断会出错。
        return head;
    ListNode* tmp_head = deleteDuplicates_recursion(head->next);
    if (head->val == tmp_head->val)
        return tmp_head;
    else
    {
        head->next = tmp_head;
        return head;
    }
}
```

## 5 删除链表的倒数第 n 个节点

[力扣](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

考虑双指针，实现如下

```c++
ListNode* removeNthFromEnd(ListNode* head, int n)
{
    //双指针，前面的指针走n步以后，后面的指针开始走，当前面的指针走到终点时，后面的指针指向倒数第n个节点
    ListNode *next = head, *pre = head;
    while (n>0)
    {
        next = next->next;
        n--;
    }
    // 这里需要判断next指针是否为空，如果为空，说明倒数第 n 个节点为头节点
    if (next== nullptr)
        return head->next;
    while (next->next!= nullptr)
    {
        next=next->next;
        pre = pre->next;
    }
    pre->next = pre->next->next;
    return head;
}
```

当然，也可以用递归方式解答：

```c++
int current;
ListNode* removeNthFromEnd_Recursion(ListNode* head, int n)
{
    // 需要一个全局变量来记录位置，就是上面的 current 。
    if (head == nullptr)
        return head;
    head->next = removeNthFromEnd_Recursion(head->next, n);
    current++;
    if (n == current)
        return head->next;
    return head;

}
```

比较难理解，关键点是栈后进先出，所以cur是从尾部计数的。当cur == n时，返回head->next即跳过了倒数第n个节点。

## 6 交换链表中的相邻结点:

[力扣](https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/)

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

递归解法：

```c++
ListNode* swapPairs(ListNode* head)
{
    // 首选递归方式，处理边界条件
    if (head == nullptr || head->next == nullptr)
        return head;

    ListNode *end = head, *front = head->next->next;
    head = head->next;

    end->next->next = end;
    end->next = swapPairs(front);
    return head;
}
```

当然还有迭代解法：



## 7 链表求和

[力扣](https://leetcode-cn.com/problems/add-two-numbers-ii/description/)

## 8 回文链表

[力扣](https://leetcode-cn.com/problems/palindrome-linked-list/)

## 9 分隔链表

[力扣](https://leetcode-cn.com/problems/split-linked-list-in-parts/description/)

## 10 链表元素按奇偶聚集

[力扣](https://leetcode-cn.com/problems/odd-even-linked-list/description/)

## 11 LRU 页面置换算法

为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

