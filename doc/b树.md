## 计划

1.  先完成基本的功能，所有的接口，测试通过。参考 github 上线程的代码，今晚上完成。
2.  实现同步，明天完成。。。
3.  https://www.cnblogs.com/nullzx/p/8729425.html 这篇应该是讲得最清楚的了。。。。
4.  https://github.com/malbrain/Btree-source-code
5.  https://github.com/neesenk/Btree

https://github.com/lindorx/lxfs 一个小型的文件系统，作为项目



实现一个简单的加密键值存储。您的代码将是一个可以被其他程序调用的函数库，而不是一个独立的可执行程序。您的库也将被评估为性能和线程安全。并发请求可能会向您的字典发出，您也可能希望在库本身中实现并发性。您将已经熟悉字典抽象数据类型，它将惟一键映射到相应的值，并支持插入、删除和搜索。您将使用B树数据结构实现您的字典，并使用修改后的微型加密算法(TEA)加密存储的值。

## b 树

B树是一种自平衡树，它在其节点中存储键值对。当我们在下面提到“键”时，我们也隐含地指每个键所链接的值。键上的比较只对键进行操作，而不对键的链接值进行操作。

每个节点可以有不同数量的子节点，由分支因子 b 决定，b 为大于等于的正整数。b 是整个树在创建时的固定属性。各节点应遵守以下规则:

-   每个节点的 n 服从 ⌈b/2⌉≤n≤b，对于内部节点，n 为子节点数。
-   例外是根节点。如果是叶结点，则服从n≤b，如果不是叶结点（根节点），则服从 2≤n≤b。
-   每个节点有n - 1个键。这个规则也适用于叶节点;它们没有n个子键，但它们仍然包含n - 1个键，其中n满足上述规则。

每个键只存在于树中的一个节点中。每个节点中的键是有序的，对于内部节点，将其子节点按顺序划分。假设一个内部节点的n - 1个键满足阶k0 < k1

< ……  < kn-2，假设n个子节点是C0, C1，…Cn-1。子节点Ci中的每个键都是> ki-1和< ki。第一个子节点(C0)中的每个键都< k0，最后一个子节点(Cn-1)中的每个键都是> kn-2。我们将使用这样的术语:键ki分隔子Ci和Ci+1，子Ci由键ki-1和ki分隔(如果是第一个或最后一个子键，则只有一个键)。

## b 树的查找

要在B树中找到关键字 k，请遵循以下算法:

1.  从根节点开始，如果键存在于该节点中，则返回键值对，这样就完成了。如果它不存在，通过比较K和节点的键来确定下一步要考虑的正确子节点。

    如果ki-1 < K < ki，则正确的子节点是Ci。

2.  移动到Ci，重复步骤1，直到找到包含K的节点。

3.  如果到达一个叶节点而K未找到，则返回未找到键。

## 微型加密算法(修改)

加密只是一个函数(“cipher”)，它在一些附加数据(“key”)的控制下，将输入数据(“明文”)转换为加密的输出数据(“密文”)。这个操作可以反过来，按照我们的目的，它使用密文并对相同的密钥数据应用解密函数，以产生相同的原始明文。TEA是一个64位的分组密码，密钥大小为128位。这意味着加密函数总是在一个由64位明文和128位密钥组成的固定大小的块上运行，并输出64位密文。解密函数接受64位密文和128位密钥，输出64位明文。

伪代码如下

## 使用TEA加密任意数据



