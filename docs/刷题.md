### 刷题套路总结

#### 动态规划

动态规划问题的一般形式事求解最值。例如最长递增子序列，最小编辑距离等。求最值最核心的问题的**穷举**，即得到所有可能的答案，然后找到最值。但是穷举会带来时间复杂度过高的问题，所以动态规划问题中存在**重叠子问题**。重叠子问题不必重复求解，所以能降低时间复杂度。重叠子问题通过【备忘录】或者【DP table】记录。另一方面，动态规划问题一定存在**最优子结构**。即可以通过子问题的求解得到原问题的解。虽然可以通过穷举得到最值，但是在复杂情况下，问题变化很大，穷举得到所有的解是一件很困难的事。只有列出所有的**状态转移方程**才能得到所有的解。

状体转移方程：**明确base case ->> 明确状态 ->> 明确选择 ->> 定义dp数组的含义**

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```





### 滑动窗口算法

滑动窗口算法通常用来求解字符串的子串问题。目的是找到一个窗口，包含所需的子串，然后左右滑动这个窗口（直到窗口右指针指向字符串的结尾），得到所需答案。

需要用到哈希表，用来判断窗口中是否包含子串。



1.把一个字符串转换成整数：

基本思路：ASCII码中的0~9是连续编码的，因此可以将单个字符与字符`'0'`相减得到其对应的数值，然后依次与已经转换生成的数字的十倍相加得到最终结果。

实现，边界及特例：str为字符串指针，用来迭代得到单个字符，遇到字符串结束符时停止迭代。str为空指针，str中有除0~9以外的字符（错误处理），str中有正负号，str表示的数能造成溢出，这三种情况需要判断。

代码：

```c
int str_to_int(char *str)
{
    int result=0;
    int flag=0;
    if(str == nullptr)
        return -1;
    while((*str) != '\0')
    {
        if((*str) == '-')
        {
            flag = 1;
        }
        else if((*str)<'0' ||(*str)>'9')
        {
            return -1;
        }
        result = result*10 + (*str - '0');
        str++;
    }
    return flag==1 ? -1*result : result;
}
```

输入输出：

完善，提交：

2.求链表中的倒数第k个节点：

