## 链表

链表是空节点或者是一个值和一个指向下一个节点的指针，因此很多链表操作都可以用递归来完成（并且递归时间复杂度一般为 O(n) );

通用操作是在链表中查找一个节点，删除一个节点，更改某个节点的值，头插法和尾插法创建链表。也就是增删改查。

实现很简单，此处不赘述

下面是链表相关的经典算法问题

### 找出两个链表的交点

输入两个链表的头指针，输出交点指针，要求常数空间复杂度（不能使用递归操作），O(n) 时间复杂度

思路：

设相交链表长度为c，链表A长度为a+c，链表B长度为b+c。

能不能通过算占用空间来求？？？？

第一步：求得AB长度和差值 d = len(A) - len(B)

第二步：长的先走 d 步，然后逐个节点，第一个相同节点即为交点。

```c++
static int GetListLength(ListNode* head)
{
    if (head == nullptr)
        return 0;
    int length = 0;
    while (head != nullptr)
    {
        head = head->next;
        length++;
    }
    return length;
}

static ListNode* StepForward(ListNode* head, int step)
{
    while (head!= nullptr && step>0)
    {
        head = head->next;
        step--;
    }
    return head;
}

static ListNode* FindIntersection(ListNode *headA, ListNode *headB)
{
    while (headA!= nullptr && headB!= nullptr)
    {
        if (headA == headB)
        {
            break;
        } else
        {
            headA = headA->next;
            headB = headB->next;
        }
    }
    if (headA != nullptr && headB!= nullptr)
        return headA;
    else
        return nullptr;
}

static ListNode *GetIntersectionNode(ListNode *headA, ListNode *headB)
{
    ListNode* intersection_node;
    int len_A;
    int len_B;

    len_A = GetListLength(headA);
    len_B = GetListLength(headB);

    int difference = abs((len_A - len_B));

    if (difference > 0)
    {
        if (len_A > len_B)
        {
            headA = StepForward(headA, difference);
            intersection_node = FindIntersection(headA, headB);
        } else
        {
            headB = StepForward(headB, difference);
            intersection_node = FindIntersection(headA, headB);
        }
    } else
    {
        intersection_node = FindIntersection(headA, headB);
    }

    return intersection_node;

}
```

这是实现代码，但是评论区我看到了一个骚答案，思路如下

链表 A 长为 a+c ，链表 B 长为 b+c ，用两个指针分别指向 A B 的头部，同时遍历链表，当其中一个到达尾部时，指向另一个链表的头部，如果有交点，会在第二趟相遇在交点。原理很简单：a+c+b = b+c+a；实现代码如下：

```c++
static ListNode* GetIntersectionNode2(ListNode *headA, ListNode *headB)
{
    if (headA == nullptr || headB == nullptr)
        return nullptr;

    ListNode *p_A = headA, *p_B = headB;

    while (p_A != p_B)
    {
        p_A = p_A ? p_A->next : headB;
        p_B = p_B ? p_B->next : headA;
    }

    if (p_A!= nullptr && p_B!= nullptr)
        return p_A;
    else
        return nullptr;

}
```

### 链表反转

反转链表是一道经典题目，用到了链表指针的处理。

有两种实现方式，分别是迭代式反转和递归式反转，其中递归反转链表值得注意

迭代实现反转链表如下：

```c++
static ListNode* ReverseListIteration(ListNode *head)
{
    if (head == nullptr)
        return nullptr;
    ListNode *current = head, *pre = nullptr;
    while (current!= nullptr)
    {
        ListNode *tmp_node = current->next;
        current->next = pre;
        pre = current;
        current = tmp_node;
    }
    return pre;
}
```

递归实现反转链表如下：

```c++
static ListNode* ReverseListRecursion(ListNode *head)
{
    if (head == nullptr || head->next == nullptr)
        return head;
    ListNode *new_head = ReverseListIteration(head->next);

    head->next->next = head;
    head->next = nullptr;
    return new_head;
}
```